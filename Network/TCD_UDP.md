## **TCP (Transmission Control Protocol)**

- 송신과 수신 간의 연결성 제공
- 서버소켓은 연결만을 담당
- 패킷 사이의 순서 보장. 패킷이 유실되면 재전송.
- HTTP 같은 응용 프로토콜은 TCP/IP 위에서 동작
- 가상 회성 방식
  - 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를배정
- 스트림 전송으로 전송 데이터의 크기가 무제한
- 전이중(Full-Duplex), 점대점(Point to Point) 방식
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제

  - 3-way handshaking과정은 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해 세션을 수립하는 과정

  ```java
  호스트 A, 호스트 B가 있을때

  해설
  1. 호스트 A가 연결해도 될까요?라고 물어보는 연결 요구(SYN flag)가 호스트B의 애플리케이션에 도착한다.
  2. 호스트 B는 이쪽에서도 연결하겠습니다라는 응답으로 (SYN/ACK) 응답을 돌려보냅니다.
  3. 호스트 A는 이쪽도 OK입니다라는 응답으로 (ACK)을 돌려보냅니다.

  실제로 일어나는일
  1. 호스트 A -----[ SYN ]---------> 호스트 B
  2. 호스트 B -----[ SYN/ACK ]----> 호스트 A
  3. 호스트 A -----[ ACK ]---------> 호스트 B
  ```

```java
## SYN
- 클라이언트가 무작위로 시퀸스 번호 x를 고르고 SYN 패킷을 보낸다. 그 밖의 다른 TCP 플래그나 옵션 값들을 포함할 수 있다.

## SYN ACK
- 서버가 시퀸스 번호 x를 1만큼 증가시키고, 무작위로 시퀸스 번호 y를 고른다.
- 서버 또한 플래그와 옵션 값들을 추가한 후 응답을 보낸다.

## ACK
- 클라이언트가 x와 y를 모두 1만큼 증가시킨 후 마지막 ACK 패킷을 보냄으로써 핸드셰이크 과정을 종료한다.
```

- 흐름 제어Flow Control 및 혼잡 제어 Congestion Control
  - 흐름제어는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
  - 혼잡제어는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
- 데이터 경계 구분 안함
- TCP의 데이터 전송에는 많은 오버헤드가 발생할 가능성
- 전송 순서 보장
- 속도는 UDP보다 느림
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다

## **UDP (User Datagram Protocol)**

- 비연결형 서비스를 지원
- 일방적으로 데이터를 send
- 데이터그램 단위로 데이터 처리
  - 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다
- 보내거나 받는다는 신호절차가 없음
- 신뢰성 없음
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다
- 데이터 경계 구분
- 전송 속도 빠름
- streaming에서 사용
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출
- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다
- 소켓 대신 IP를 기반으로 데이터를 전송
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다
